package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"log"

	"github.com/Big-Scale/Commerce/db/scheme"
	"github.com/Big-Scale/Commerce/graph"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input graph.CreateProductInput) (*graph.Product, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("1: Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()
	product := graph.Product{Name: input.Name, Sku: input.Sku, Price: input.Price, CategoryID: &input.CategoryID, Description: input.Description}
	log.Println("product error", product)
	err = db.Create(&product).Error
	if err != nil {
		log.Println("2: Unable to connect to database", err)
		return nil, err
	}
	return &product, err
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input graph.UpdateProductInput) (*graph.Product, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()

	updateProduct := graph.Product{
		ID:          input.ID,
		Name:        input.Name,
		Sku:         input.Sku,
		Price:       input.Price,
		CategoryID:  &input.CategoryID,
		Description: input.Description,
	}

	err = db.Model(&graph.Product{}).Where("id=?", input.ID).Updates(&updateProduct).Error
	if err != nil {
		log.Println(err)
		return nil, err
	}
	db.Save(&updateProduct)
	return &updateProduct, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id uint) (bool, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return false, err
	}
	defer db.Close()

	var product graph.Product
	db.Where("id = ?", id).First(&product).Delete(&product)

	return true, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id uint) (*graph.Product, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()
	product := graph.Product{}
	err = db.First(&product, id).Error
	if err != nil {
		return nil, err
	}
	return &product, err
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*graph.Product, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()
	products := []*graph.Product{}
	err = db.Find(&products).Error
	if err != nil {
		return nil, err
	}
	return products, err
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, name string) ([]*graph.Product, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()
	products := []*graph.Product{}
	err = db.Where("name LIKE ?", "%"+name+"%").Find(&products).Error
	if err !=nil{
		log.Println("Unable to search the products: ", err)
		return nil, err
	}
	return products, nil
}

// ProductsByCategory is the resolver for the productsByCategory field.
func (r *queryResolver) ProductsByCategory(ctx context.Context, categoryId uint) ([]*graph.Product, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()
	products := []*graph.Product{}
	err = db.Where("category_id = ?", categoryId).Find(&products).Error
	if err !=nil{
		log.Println("Unable to search the products by category: ", err)
		return nil, err
	}
	return products, nil
}
