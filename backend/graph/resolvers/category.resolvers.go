package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/Big-Scale/Commerce/db/scheme"
	"github.com/Big-Scale/Commerce/graph"
)

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input graph.CreateCategoryInput) (*graph.Category, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()

	// imageURL, err := handleFileUpload(input.Image)
	// if err != nil {
	// 	log.Printf("Failed to upload image: %v", err)
	// 	return nil, fmt.Errorf("failed to upload image: %v", err)
	// }

	// Create the category with the uploaded image URL
	category := graph.Category{
		Name:        input.Name,
		Description: *input.Description, // Save the URL/path to your image
	}

	err = db.Create(&category).Error
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	return &category, err
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, input graph.UpdateCategoryInput) (*graph.Category, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()

	updateCategory := graph.Category{}
	result := db.First(&updateCategory, input.ID)

	if result.Error != nil {
		log.Println("category with not found: ", input.ID, err)
		return nil, err
	}
	if input.Name != nil {
		updateCategory.Name = *input.Name
	}

	if input.Description != nil {
		updateCategory.Description = *input.Description
	}

	// if input.Image != nil {
	// 	imageURL, err := handleFileUpload(*input.Image)
	// 	if err != nil {
	// 		log.Println("Failed to upload new image: ", err)
	// 		return nil, err
	// 	}
	// 	updateCategory.Image = imageURL
	// }

	db.Save(&updateCategory)
	return &updateCategory, nil
}

// DeleteCategory is the resolver for the deleteCategory field.
func (r *mutationResolver) DeleteCategory(ctx context.Context, id uint) (bool, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return false, err
	}
	defer db.Close()
	deleteCategory := graph.Category{}
	err = db.Where("id=?", id).Delete(&deleteCategory).Error

	if err != nil {
		log.Println("Unable to delete the category: ", err)
		return false, err
	}
	return true, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id uint) (*graph.Category, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()

	category := graph.Category{}
	err = db.First(&category, id).Error
	if err != nil {
		return nil, err
	}
	return &category, err
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*graph.Category, error) {
	db, err := scheme.FetchConnection()
	if err != nil {
		log.Println("Unable to connect to database", err)
		return nil, err
	}
	defer db.Close()
	categories := []*graph.Category{}
	err = db.Find(&categories).Error
	if err != nil {
		return nil, err
	}
	return categories, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func handleFileUpload(fileUpload graphql.Upload) (string, error) {
	// Create a unique file name, for example using the uploaded file's name and a timestamp
	fileName := fmt.Sprintf("%d-%s", time.Now().Unix(), fileUpload.Filename)
	targetPath := filepath.Join("uploads", fileName)
	log.Println("TARGETPATH: ", targetPath)
	// Open the target file for writing
	out, err := os.Create(targetPath)
	if err != nil {
		return "", err
	}
	defer out.Close()

	// Copy the uploaded file's content to the target file
	_, err = io.Copy(out, fileUpload.File)
	if err != nil {
		return "", err
	}

	// Here, return the path or URL to access the file
	// For local development, this might just be the file's relative path
	// In production, you might upload the file to cloud storage and return a URL
	return targetPath, nil
}
